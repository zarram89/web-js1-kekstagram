# Личный проект «Кексаграм»

* Автор: [Рамиль Зарипов](https://github.com/zarram89).

---

<details>
<summary><b>Техническое задание</b></summary>

## О проекте
Кекстаграм — сервис просмотра изображений. Пользователям предоставлена возможность загружать свои фотографии или просматривать фотографии, загруженные ранее другими пользователями.

## Описание функциональности

### 1. Загрузка нового изображения на сайт и заполнение информации о нём

**1.1. Загрузка нового изображения:**
- выбор файла с изображением для загрузки;
- изменение масштаба изображения;
- применение одного из заранее заготовленных эффектов;
- выбор глубины эффекта с помощью ползунка;
- добавление текстового комментария;
- добавление хэштегов.

**1.2.** Выбор изображения для загрузки осуществляется с помощью стандартного контрола загрузки файла `.img-upload__input`, который стилизован под букву «О» в логотипе. После выбора изображения (изменения значения поля `.img-upload__input`), показывается форма редактирования изображения. У элемента `.img-upload__overlay` удаляется класс `hidden`, а `body` задаётся класс `modal-open`.

После выбора изображения пользователем с помощью стандартного контрола загрузки файла `.img-upload__input`, нужно подставить его в форму редактирования вместо тестового изображения в блок предварительного просмотра и в превью эффектов.

**1.3.** Закрытие формы редактирования изображения производится либо нажатием на кнопку `.img-upload__cancel`, либо нажатием клавиши `Esc`. Элементу `.img-upload__overlay` возвращается класс `hidden`. У элемента `body` удаляется класс `modal-open`.

### 2. Редактирование изображения и ограничения, накладываемые на поля

**2.1. Масштаб:**
- При нажатии на кнопки `.scale__control--smaller` и `.scale__control--bigger` должно изменяться значение поля `.scale__control--value`;
- Значение должно изменяться с шагом в 25. Например, если значение поля установлено в 50%, после нажатия на «+», значение должно стать равным 75%. Максимальное значение — 100%, минимальное — 25%. Значение по умолчанию — 100%;
- При изменении значения поля `.scale__control--value` изображению внутри `.img-upload__preview` должен добавляться соответствующий стиль CSS, который с помощью трансформации `scale` задаёт масштаб. Например, если в поле стоит значение 75%, то в стиле изображения должно быть написано `transform: scale(0.75)`.

**2.2. Наложение эффекта на изображение:**
- По умолчанию должен быть выбран эффект «Оригинал».
- На изображение может накладываться только один эффект.
- Интенсивность эффекта регулируется перемещением ползунка в слайдере. Слайдер реализуется сторонней библиотекой для реализации слайдеров **noUiSlider**. Уровень эффекта записывается в поле `.effect-level__value` в виде числа. При изменении уровня интенсивности эффекта (предоставляется API слайдера), CSS-стили картинки внутри `.img-upload__preview` обновляются следующим образом:
  - Для эффекта «Хром» — `filter: grayscale(0..1)` с шагом 0.1;
  - Для эффекта «Сепия» — `filter: sepia(0..1)` с шагом 0.1;
  - Для эффекта «Марвин» — `filter: invert(0..100%)` с шагом 1%;
  - Для эффекта «Фобос» — `filter: blur(0..3px)` с шагом 0.1px;
  - Для эффекта «Зной» — `filter: brightness(1..3)` с шагом 0.1;
  - Для эффекта «Оригинал» CSS-стили `filter` удаляются.
- При выборе эффекта «Оригинал» слайдер и его контейнер (элемент `.img-upload__effect-level`) скрываются.
- При переключении эффектов, уровень насыщенности сбрасывается до начального значения (100%): слайдер, CSS-стиль изображения и значение поля должны обновляться.

**2.3. Хэштеги:**
- хэштег начинается с символа `#` (решётка);
- строка после решётки должна состоять из букв и чисел и не может содержать пробелы, спецсимволы (`#`, `@`, `$` и т. п.), символы пунктуации (тире, дефис, запятая и т. п.), эмодзи и т. д.;
- хеш-тег не может состоять только из одной решётки;
- максимальная длина одного хэштега 20 символов, включая решётку;
- хэштеги нечувствительны к регистру: `#ХэшТег` и `#хэштег` считаются одним и тем же тегом;
- хэштеги разделяются пробелами;
- один и тот же хэштег не может быть использован дважды;
- нельзя указать больше пяти хэштегов;
- хэштеги необязательны;
- если фокус находится в поле ввода хэштега, нажатие на `Esc` не должно приводить к закрытию формы редактирования изображения.

**2.4. Комментарий:**
- комментарий не обязателен;
- длина комментария не может составлять больше 140 символов;
- если фокус находится в поле ввода комментария, нажатие на `Esc` не должно приводить к закрытию формы редактирования изображения.

### 3. Отправка данных на сервер

**3.1.** После заполнения всех данных, при нажатии на кнопку «Отправить», все данные из формы, включая изображения, с помощью AJAX-запроса отправляются на сервер `https://32.javascript.htmlacademy.pro/kekstagram` методом `POST` с типом `multipart/form-data`. На время выполнения запроса к серверу кнопка «Отправить» блокируется.

**3.2.** Страница реагирует на неправильно введённые значения в форму. Если данные, введённые в форму, не соответствуют ограничениям, указанным в пунктах 2.3 и 2.4, форму невозможно отправить на сервер.

При попытке отправить форму с неправильными данными отправки не происходит, а пользователю показываются ошибки для неверно заполненных полей (для проверки данных используется сторонняя библиотека **Pristine**).

Ошибки выводятся внутри блока `.img-upload__field-wrapper` соответствующего поля. Также, если поле заполнено неверно, блоку, в котором выводится текст ошибки, добавляется класс `.img-upload__field-wrapper--error`.

Пример:
```html
<div class="pristine-error img-upload__field-wrapper--error" style="">Неправильный хэштег</div>
```

Для разных ошибок показываются разные сообщения. Следует разделять случаи, когда:
- введён невалидный хэштег;
- превышено количество хэштегов;
- хэштеги повторяются;
- длина комментария больше 140 символов.

Количество одновременно показываемых сообщений для одного поля разработчик определяет самостоятельно.

**3.3.** При успешной отправке формы форма редактирования изображения закрывается, все данные, введённые в форму, и контрол фильтра приходят в исходное состояние:
- масштаб возвращается к 100%;
- эффект сбрасывается на «Оригинал»;
- поля для ввода хэштегов и комментария очищаются;
- поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

**3.4.** Если отправка данных прошла успешно, показывается соответствующее сообщение. Разметку сообщения, которая находится в блоке `#success` внутри шаблона `template`, нужно разместить перед закрывающим тегом `</body>`. Сообщение должно удаляться со страницы после нажатия на кнопку `.success__button`, по нажатию на клавишу `Esc` и по клику на произвольную область экрана за пределами блока с сообщением.

**3.5.** Если при отправке данных произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке `#error` внутри шаблона `template`, нужно разместить перед закрывающим тегом `</body>`. Сообщение должно удаляться со страницы после нажатия на кнопку `.error__button`, по нажатию на клавишу `Esc` и по клику на произвольную область экрана за пределами блока с сообщением. В таком случае вся введённая пользователем информация сохраняется, чтобы у него была возможность отправить форму повторно.

**3.6.** Нажатие на кнопку `.img-upload__cancel` приводит к закрытию формы и возвращению всех данных и контрола фильтра к исходному состоянию (описано в пункте 3.3). Поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

### 4. Просмотр загруженных изображений

**4.1.** Загрузка изображений от других пользователей производится сразу после открытия страницы с удалённого сервера: `https://32.javascript.htmlacademy.pro/kekstagram/data`.

**4.2.** Если при загрузке данных с сервера произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке `#data-error` внутри шаблона `template`, нужно разместить перед закрывающим тегом `</body>`. Сообщение удаляется со страницы через 5 секунд.

**4.3.** Все загруженные изображения показаны на главной странице в виде миниатюр. DOM-элемент миниатюры генерируется на основе шаблонного элемента `picture`, расположенного в элементе `template` на странице.

**4.4.** При нажатии на любую из миниатюр, показывается блок `.big-picture`, содержащий полноэкранное изображение с количеством лайков и комментариев. Элементу `body` задаётся класс `modal-open`. Данные, описывающие изображение, должны подставляться в соответствующие элементы в разметке.

**4.5.** Выход из полноэкранного режима просмотра фотографии осуществляется либо нажатием на иконку крестика `.big-picture__cancel` в правом верхнем углу блока `.big-picture`, либо нажатием на клавишу `Esc`. У элемента `body` удаляется класс `modal-open`.

**4.6.** Все комментарии к изображению выводятся в блок `.social__comments`. Сразу после открытия изображения в полноэкранном режиме отображается не более 5 комментариев. Количество показанных комментариев и общее число комментариев отображается в блоке `.social__comment-count`. Пример разметки списка комментариев приведён в блоке `.social__comments`. Комментарий оформляется отдельным элементом списка `li` с классом `social__comment`. Аватарка автора комментария отображается в блоке `.social__picture`. Имя автора комментария отображается в атрибуте `alt` его аватарки. Текст комментария выводится в блоке `.social__text`.

**4.7.** Отображение дополнительных комментариев происходит при нажатии на кнопку `.comments-loader`. При нажатии на кнопку отображается не более 5 новых комментариев. При изменении количества показанных комментариев число показанных комментариев в блоке `.social__comment-count` также изменяется.

**4.8.** Если все комментарии показаны, кнопку `.comments-loader` следует скрыть, добавив класс `hidden`.

### 5. Фильтрация изображений от других пользователей

**5.1. Доступные фильтры:**
- «По умолчанию» — фотографии в изначальном порядке с сервера;
- «Случайные» — 10 случайных, не повторяющихся фотографий;
- «Обсуждаемые» — фотографии, отсортированные в порядке убывания количества комментариев.

**5.2.** Блок, с помощью которого производится фильтрация фотографий, скрыт изначально и показывается только после получения от сервера данных об изображениях других пользователей.

**5.3.** При переключении фильтров, отрисовка изображений, подходящих под новый фильтр, должна производиться не чаще, чем один раз 500 мс (устранение дребезга).

</details>

---


<details>
<summary><b>Задание module4-task1: Генерация временных данных</b></summary>

### Описание
В этом задании наша цель научиться генерировать временные данные для дальнейшей разработки интерфейса. Данные хоть временные и ненастоящие, но должны быть идентичны по своей структуре оригинальным.

### Подготовка
В директории `/js` вашего проекта расположен пустой файл `main.js`. Подключите его в файле `index.html` и выполняйте задание в нём.

### Генерация данных

#### Структура объекта фотографии

Нужно создать массив из **25 сгенерированных объектов**. Каждый объект массива — описание фотографии, опубликованной пользователем.

Структура каждого объекта должна быть следующей:

- **id** (число) — идентификатор опубликованной фотографии. Это число от 1 до 25. Идентификаторы не должны повторяться.
- **url** (строка) — адрес картинки вида `photos/{{i}}.jpg`, где `{{i}}` — это число от 1 до 25. Адреса картинок не должны повторяться.
- **description** (строка) — описание фотографии. Описание придумайте самостоятельно.
- **likes** (число) — количество лайков, поставленных фотографии. Случайное число от 15 до 200.
- **comments** (массив объектов) — список комментариев, оставленных другими пользователями к этой фотографии. Количество комментариев к каждой фотографии — случайное число от 0 до 30.

#### Структура объекта комментария

```javascript
{
  id: 135,
    avatar: 'img/avatar-6.svg',
    message: 'В целом всё неплохо. Но не всё.',
    name: 'Артём',
}
```

- **id** (число) — идентификатор комментария. Любое число. Идентификаторы не должны повторяться.
- **avatar** (строка) — строка, значение которой формируется по правилу `img/avatar-{{случайное число от 1 до 6}}.svg`. Аватарки подготовлены в директории `img`.
- **message** (строка) — текст комментария. Одно или два случайных предложения из представленных ниже:
  - Всё отлично!
  - В целом всё неплохо. Но не всё.
  - Когда вы делаете фотографию, хорошо бы убирать палец из кадра. В конце концов это просто непрофессионально.
  - Моя бабушка случайно чихнула с фотоаппаратом в руках и у неё получилась фотография лучше.
  - Я поскользнулся на банановой кожуре и уронил фотоаппарат на кота и у меня получилась фотография лучше.
  - Лица у людей на фотке перекошены, как будто их избивают. Как можно было поймать такой неудачный момент?!
- **name** (строка) — имя автора комментария. Случайное имя из набора, который вы составите сами.

### План выполнения

- [x] Обновить `Readme.md` с полным техническим заданием
- [ ] Подключить `main.js` к `index.html`
- [ ] Реализовать вспомогательные функции для генерации случайных значений
- [ ] Реализовать функции для создания комментариев
- [ ] Реализовать функции для создания фотографий
- [ ] Вывести сгенерированные данные в консоль для проверки

### Ход выполнения

#### 1. Обновление Readme.md ✅
Добавлено техническое задание проекта в свернутом виде (тег `<details>`) и описание текущей задачи module4-task1 с требованиями к структуре данных.

#### 2. Подключение main.js ✅
В файле `index.html` перед закрывающим тегом `</body>` добавлена строка:
```html
<script src="js/main.js"></script>
```

#### 3. Реализация функций генерации данных ✅
В файле `js/main.js` реализованы следующие функции:

**Вспомогательные функции:**
- `getRandomInteger(min, max)` — генерация случайного целого числа в заданном диапазоне
- `getRandomArrayElement(elements)` — получение случайного элемента из массива
- `createIdGenerator()` — фабрика для создания генераторов уникальных ID

**Константы:**
- `MESSAGES` — массив из 6 сообщений для комментариев
- `NAMES` — массив из 12 имен комментаторов
- `DESCRIPTIONS` — массив из 25 описаний фотографий

**Функции генерации:**
- `createComment()` — создание объекта комментария с полями: id, avatar, message, name
- `createComments()` — создание массива случайного количества комментариев (0-30)
- `createPhoto(index)` — создание объекта фотографии с полями: id, url, description, likes, comments
- `createPhotos()` — создание массива из 25 фотографий

**Генерация и вывод:**
```javascript
const photos = createPhotos();
console.log(photos);
```

### Проверка результата

#### Автоматическая проверка ✅
1. Открыт файл `index.html` в браузере
2. Открыта консоль разработчика (F12)
3. В консоли выведен массив из 25 объектов

#### Ручная проверка ✅
Проверена структура данных:
- ✅ Массив содержит ровно 25 элементов
- ✅ Каждая фотография имеет уникальный `id` от 1 до 25
- ✅ URL фотографий имеют формат `photos/1.jpg` ... `photos/25.jpg` (уникальны)
- ✅ Описания фотографий выбираются случайно из предложенного набора
- ✅ Количество лайков находится в диапазоне 15-200
- ✅ Количество комментариев находится в диапазоне 0-30
- ✅ У каждого комментария уникальный ID
- ✅ Аватары комментариев имеют формат `img/avatar-X.svg`, где X от 1 до 6
- ✅ Сообщения комментариев состоят из одного или двух предложений из предложенного набора
- ✅ Имена авторов комментариев выбираются случайно из подготовленного списка

### Результат
✅ Задание module4-task1 выполнено полностью. Созданы все необходимые функции для генерации тестовых данных, соответствующих техническому заданию.

</details>


<details>
<summary><b>Задание module5-task1: Разделение кода на модули</b></summary>

### Описание
Разделите код, уже написанный в `main.js`, на отдельные ES2015-модули. `main.js` станет главным модулем, точкой входа. В этом файле должны остаться только импорты других модулей, а также код, который необходим для их работы.

### Пример разбиения на модули
- **main.js** — точка входа. Модуль, который связывает другие модули
- **util.js** — модуль с вспомогательными функциями
- **data.js** — модуль, который создаёт данные

Указанное выше разделение на модули — это только пример. Вы можете разделить код на модули так, как считаете нужным.

### Задачи
Импортируйте нужные модули в точку входа, а точку входа подключите в `index.html` как скрипт-модуль.

По желанию, вы можете перечитать техническое задание и подумать, какие ещё модули потребуются в приложении, а после завести под них пустые файлы, чтобы сразу обозначить файловую структуру проекта.

### Реализованная структура модулей

#### 1. Основные модули

**util.js** — Вспомогательные функции:
- `getRandomInteger(min, max)` — генерация случайного целого числа
- `getRandomArrayElement(elements)` — выбор случайного элемента из массива
- `createIdGenerator()` — фабрика для создания генераторов уникальных ID

**data.js** — Генерация данных:
- Импортирует функции из `util.js`
- Содержит константы (`MESSAGES`, `NAMES`, `DESCRIPTIONS`)
- Содержит функции создания комментариев и фотографий
- Экспортирует `createPhotos()` для создания массива из 25 фотографий

**main.js** — Точка входа:
- Импортирует `createPhotos` из `data.js`
- Генерирует данные
- Выводит результат в консоль

#### 2. Заготовки модулей для будущей разработки

На основе технического задания созданы заготовки для следующих модулей:
- **form.js** — работа с формой загрузки изображения
- **scale.js** — изменение масштаба изображения
- **effect.js** — применение эффектов к изображению
- **validation.js** — валидация хэштегов и комментариев
- **api.js** — работа с сервером
- **gallery.js** — отображение миниатюр фотографий
- **preview.js** — полноэкранный просмотр фотографии
- **filter.js** — фильтрация изображений
- **upload.js** — загрузка данных на сервер

### Изменения в проекте

#### index.html
Изменено подключение скрипта:
```html
<script src="js/main.js" type="module"></script>
```

### Проверка результата

1. Открыт `index.html` в браузере
2. Открыта консоль разработчика (F12)
3. ✅ В консоли выводится массив из 25 фотографий
4. ✅ Отсутствуют ошибки в консоли
5. ✅ Модули корректно импортируют друг друга

### Возможные проблемы и решения

**Проблема:** CORS-ошибка при локальном открытии файла
**Решение:** Использовать локальный веб-сервер (например, Live Server в VS Code или `python -m http.server`)

**Проблема:** Браузер не поддерживает ES6-модули
**Решение:** Использовать современный браузер (Chrome, Firefox, Edge последних версий)

### Преимущества модульного подхода

1. **Разделение ответственности**: каждый модуль выполняет свою задачу
2. **Переиспользование**: модули можно импортировать в разных частях проекта
3. **Тестируемость**: модули удобно тестировать изолированно
4. **Масштабируемость**: легко добавлять новые модули
5. **Читаемость**: структура кода понятна и логична
6. **Инкапсуляция**: внутренние функции модуля недоступны извне

### Результат
✅ Задание module5-task1 выполнено полностью. Код разделен на логические модули, создана основа для дальнейшей разработки проекта.

</details>


<details>
<summary><b>Задание module7-task1: Отрисовка миниатюр фотографий</b></summary>

### Описание
Отобразить фотографии других пользователей. Завести модуль, который будет отвечать за отрисовку миниатюр.

На основе временных данных для разработки и шаблона `#picture` создать DOM-элементы, соответствующие фотографиям, и заполнить их данными.

### Требования к заполнению

- Адрес изображения `url` подставить как атрибут `src` изображения
- Описание изображения `description` подставить в атрибут `alt` изображения
- Количество лайков `likes` вывести в блок `.picture__likes`
- Количество комментариев `comments.length` вывести в блок `.picture__comments`

Отрисовать сгенерированные DOM-элементы в блок `.pictures`. Для вставки элементов использовать `DocumentFragment`.

### Реализованная структура

#### 1. Модуль gallery.js

**Функции модуля:**

- `createPictureElement(photo)` — создание DOM-элемента миниатюры
  - Клонирует шаблон `#picture`
  - Заполняет данными из объекта photo
  - Возвращает готовый элемент

- `renderPictures(photos)` — отрисовка всех миниатюр
  - Создает `DocumentFragment`
  - Создает элементы для каждой фотографии
  - Вставляет фрагмент в контейнер `.pictures` за одну операцию

**Экспорт:**
```javascript
export { renderPictures };
```

#### 2. Интеграция в main.js

Модуль подключен в проект через импорт:

```javascript
import { createPhotos } from './data.js';
import { renderPictures } from './gallery.js';

const photos = createPhotos();
renderPictures(photos);
```

### Проверка результата

1. Открыт `index.html` в браузере через локальный сервер
2. ✅ На странице отображаются 25 миниатюр фотографий
3. ✅ Каждая миниатюра содержит:
  - Изображение с корректным URL (`photos/1.jpg` ... `photos/25.jpg`)
  - Описание в атрибуте `alt`
  - Количество лайков (15-200)
  - Количество комментариев (0-30)
4. ✅ Использован `DocumentFragment` для оптимизации
5. ✅ Отсутствуют ошибки в консоли

### Особенности реализации

1. **Производительность**: `DocumentFragment` минимизирует количество reflow при вставке 25 элементов
2. **Модульность**: отрисовка полностью отделена от генерации данных
3. **Шаблонизация**: использование `<template>` обеспечивает быстрое клонирование
4. **Переиспользование**: функцию можно вызывать повторно для обновления галереи

### Результат
✅ Задание module7-task1 выполнено полностью. Миниатюры корректно отображаются с данными из временного массива.

</details>


<details>
<summary><b>Задание module8-task1: Полноразмерный просмотр фотографий</b></summary>

### Описание
Реализовать сценарий просмотра фотографий в полноразмерном режиме. При клике на миниатюру открывается модальное окно с большим изображением, комментариями и лайками.

### Требования

При клике на миниатюру должно открываться окно `.big-picture` (удаляется класс `hidden`). Окно заполняется данными:

- **Изображение**: `url` → `.big-picture__img img[src]`
- **Лайки**: `likes` → `.likes-count`
- **Описание**: `description` → `.social__caption`
- **Комментарии**: массив `comments` → `.social__comments`
- **Счетчики**: показано и всего → `.social__comment-shown-count` и `.social__comment-total-count`

Каждый комментарий имеет структуру:
```html
<li class="social__comment">
  <img class="social__picture" src="{{avatar}}" alt="{{name}}" width="35" height="35">
  <p class="social__text">{{message}}</p>
</li>
```

После открытия окна:
- Скрыть блоки `.social__comment-count` и `.comments-loader`
- Добавить класс `modal-open` к `<body>`
- Реализовать закрытие по Esc и клику на `.big-picture__cancel`

### Реализованная структура

#### 1. Модуль preview.js

**Основные функции:**

- `renderComments(comments)` — отрисовка списка комментариев с использованием DocumentFragment
- `fillBigPicture(photo)` — заполнение всех данных окна
- `showBigPicture(photo)` — открытие модального окна
- `closeBigPicture()` — закрытие модального окна
- `onDocumentKeydown(evt)` — обработчик клавиши Esc

**Экспорт:**
```javascript
export { showBigPicture };
```

#### 2. Интеграция в gallery.js

Добавлен импорт и обработчик клика на каждую миниатюру:

```javascript
import { showBigPicture } from './preview.js';

pictureElement.addEventListener('click', (evt) => {
  evt.preventDefault();
  showBigPicture(photo);
});
```

### Проверка результата

1. Открыта страница в браузере
2. ✅ Клик на миниатюру открывает модальное окно
3. ✅ Отображаются корректные данные:
  - Большое изображение
  - Количество лайков
  - Описание фотографии
  - Все комментарии с аватарами
4. ✅ Окно закрывается по клику на кнопку
5. ✅ Окно закрывается по нажатию Esc
6. ✅ Класс `modal-open` добавляется/удаляется корректно
7. ✅ Блоки счетчика и загрузки скрыты

### Особенности реализации

1. **Модульность**: логика просмотра отделена от галереи
2. **UX**: блокировка прокрутки body при открытом окне
3. **Оптимизация**: DocumentFragment для вставки комментариев
4. **Доступность**: закрытие по Esc
5. **Замыкания**: сохранение ссылки на объект photo в обработчике

### Результат
✅ Задание module8-task1 выполнено полностью. Полноразмерный просмотр работает корректно со всеми требованиями.

</details>


<details>
<summary><b>Задание module8-task2: Постраничная загрузка комментариев</b></summary>

### Описание
Улучшить пользовательский интерфейс полноразмерного просмотра, реализовав постраничную загрузку комментариев. Комментарии должны показываться не все сразу, а порциями по 5 штук с возможностью загрузки следующих порций по клику на кнопку "Загрузить ещё".

### Требования

1. Показать блоки `.social__comment-count` и `.comments-loader` (убрать `hidden`)
2. При открытии показывать только первые 5 комментариев
3. По клику на кнопку показывать следующие 5 комментариев
4. Обновлять счетчик `.social__comment-shown-count`
5. Скрывать кнопку когда все комментарии показаны

> Примечание: никакой загрузки с сервера не происходит, просто показываются следующие комментарии из массива.

### Реализованная структура

#### Новые константы и переменные

```javascript
const COMMENTS_PER_PORTION = 5;
let currentComments = [];
let shownCommentsCount = 0;
```

#### Обновленные функции

- `renderComments(count)` — показ первых `count` комментариев
- `updateCommentsCount()` — обновление счетчиков и управление видимостью кнопки
- `loadMoreComments()` — загрузка следующих 5 комментариев
- `fillBigPicture()` — сохранение комментариев и показ первых 5
- `showBigPicture()` — показ блока счетчика (убрать скрытие)

#### Обработчик кнопки

```javascript
commentsLoader.addEventListener('click', loadMoreComments);
```

### Проверка результата

1. ✅ При открытии показаны первые 5 комментариев
2. ✅ Счетчик показывает "5 из X"
3. ✅ Кнопка "Загрузить ещё" видна
4. ✅ По клику загружаются следующие 5 комментариев
5. ✅ Счетчик обновляется (10 из X, 15 из X, и т.д.)
6. ✅ Когда все комментарии показаны, кнопка скрывается
7. ✅ Для фото с ≤5 комментариями кнопка скрыта сразу

### Особенности реализации

1. **Управление состоянием**: переменные `currentComments` и `shownCommentsCount`
2. **Инкрементальная отрисовка**: использование `slice(0, count)`
3. **Умное управление кнопкой**: автоматическое показ/скрытие
4. **Math.min**: предотвращение выхода за пределы массива
5. **Константа COMMENTS_PER_PORTION**: легко настроить размер порции

### Результат
✅ Задание module8-task2 выполнено полностью. Постраничная загрузка комментариев работает корректно.

</details>

<details>
<summary><b>Задание module9-task1: Валидация формы загрузки изображения</b></summary>

### Описание

Добавить в проект валидацию, проверки введённых данных, чтобы подсказать пользователю, какие данные мы от него ждём, а себе и бэкендеру упростить работу с этими данными.

Заведите модуль, который будет отвечать за работу с формой.

Пропишите тегу `<form>` правильные значения атрибутов `method` и `enctype` и адрес `action` для отправки формы на сервер.

Обратите внимание. В разделе про работу с сетью мы доработаем механизм отправки данных, а пока достаточно правильных атрибутов у тега `<form>`.

Если форма заполнена верно, то после отправки покажется страница сервера (по адресу из атрибута action тега form) с успешно отправленными данными. Если же форма пропустила какие-то некорректные значения, то будет показана страница с допущенными ошибками. В идеале у пользователя не должно быть сценария, при котором он может отправить некорректную форму.

Изучите, что значит загрузка изображения, и как, когда и каким образом показывается форма редактирования изображения. Напишите код и добавьте необходимые обработчики для реализации этого пункта техзадания. В работе вы можете опираться на код показа окна с полноразмерной фотографией, который вы, возможно, уже написали в предыдущей домашней работе.

**Важно.** Подстановка выбранного изображения в форму — это отдельная домашняя работа. В данном задании этот пункт реализовывать не нужно.

После реализуйте закрытие формы.

Обратите внимание, что при закрытии формы дополнительно необходимо сбрасывать значение поля выбора файла `.img-upload__input`. В принципе, всё будет работать, если при повторной попытке загрузить в поле другую фотографию. Но! Событие `change` не сработает, если пользователь попробует загрузить ту же фотографию, а значит окно с формой не отобразится, что будет нарушением техзадания. Значение других полей формы также нужно сбрасывать.

Напишите код для валидации формы добавления изображения, используя библиотеку Pristine (скрипт находится в директории `/vendor/pristine`). Список полей для валидации:
- Хэштеги
- Комментарий

Реализуйте логику проверки так, чтобы, как минимум, она срабатывала при попытке отправить форму и не давала этого сделать, если форма заполнена не по правилам. При желании, реализуйте проверки сразу при вводе значения в поле.

**Как отменить обработчик Esc при фокусе?**
Задача не имеет одного верного решения, однако намекнём на самый простой — использовать `stopPropagation` для события нажатия клавиш в поле при фокусе.

**Валидация хеш-тегов?**
Для валидации хэштегов вам придётся вспомнить, как работать с массивами. Набор хэштегов можно превратить в массив, воспользовавшись методом `.split()`. Он разбивает строки на массивы. После этого, вы можете написать цикл, который будет ходить по полученному массиву и проверять каждый из хэштегов на предмет соответствия ограничениям. Если хотя бы один из тегов не проходит нужных проверок, показывать сообщение об ошибке.

Поля, не перечисленные в техзадании, но существующие в разметке, особой валидации не требуют.

### План выполнения

1. [x] Настройка формы
  - [x] Добавить атрибуты `method="POST"`, `enctype="multipart/form-data"` и `action` к форме
2. [x] Создание модуля `form.js`
  - [x] Реализовать открытие формы при выборе файла
  - [x] Реализовать закрытие формы по кнопке и Esc
  - [x] Учесть фокус в полях при нажатии Esc
  - [x] Сбросить все поля при закрытии
3. [x] Создание модуля `validation.js`
  - [x] Подключить библиотеку Pristine
  - [x] Реализовать валидацию хэштегов (формат, длина, уникальность, количество)
  - [x] Реализовать валидацию  комментариев (длина)
4. [x] Интеграция
  - [x] Импортировать модули в `main.js`

### Ход выполнения

#### 1. Настройка формы ✅

В файле `index.html` (строка 35) добавлены атрибуты к форме:
```html
<form class="img-upload__form" id="upload-select-image"
  method="POST"
  enctype="multipart/form-data"
  action="https://32.javascript.htmlacademy.pro/kekstagram"
  autocomplete="off">
```

#### 2. Реализация модуля form.js ✅

**Файл:** `js/form.js`

**Функциональность:**
- Открытие формы при выборе файла через input `.img-upload__input`
- Показ оверлея `.img-upload__overlay` (убрать класс `hidden`)
- Добавление класса `modal-open` к `body`
- Закрытие формы по кнопке `.img-upload__cancel`
- Закрытие формы по клавише `Esc` (с проверкой фокуса)
- Сброс всех полей формы при закрытии

**Ключевые решения:**
- Использование `function` declarations для избежания проблем с hoisting
- Проверка `document.activeElement` для определения фокуса в текстовых полях
- Сброс значения `uploadInput.value = ''` для корректной работы повторного выбора

#### 3. Реализация модуля validation.js ✅

**Файл:** `js/validation.js`

**Валидация хэштегов:**
- Формат: `#` + буквы/цифры (1-19 символов после #)
- Регулярное выражение: `/^#[a-zа-яё0-9]{1,19}$/i`
- Максимум 5 хэштегов
- Регистронезависимая уникальность через `Set` и `.toLowerCase()`
- Сообщения об ошибках:
  - "Неправильный хэштег"
  - "Превышено количество хэштегов"
  - "Хэштеги повторяются"

**Валидация комментария:**
- Максимум 140 символов
- Сообщение: "Длина комментария больше 140 символов"

**Конфигурация Pristine:**
```javascript
const pristine = new Pristine(form, {
  classTo: 'img-upload__field-wrapper',
  errorTextParent: 'img-upload__field-wrapper',
  errorTextClass: 'img-upload__field-wrapper--error',
});
```

#### 4. Интеграция ✅

В `main.js` добавлены импорты:
```javascript
import './form.js';
import './validation.js';
```

### Проверка результата

#### Автоматизированное тестирование

1. ✅ **Библиотека Pristine загружена**
  - Проверка: `typeof Pristine === 'function'`

2. ✅ **Невалидный хэштег**
  - Входные данные: `invalid` (без #)
  - Результат: ошибка "Неправильный хэштег"

3. ✅ **Валидные хэштеги**
  - Входные данные: `#test #hello`
  - Результат: валидация пройдена

4. ✅ **Дубликаты хэштегов**
  - Входные данные: `#test #TEST #Test`
  - Результат: ошибка "Хэштеги повторяются"

5. ✅ **Превышение лимита**
  - Входные данные: `#one #two #three #four #five #six`
  - Результат: ошибка "Превышено количество хэштегов"

6. ✅ **Длинный хэштег**
  - Входные данные: `#verylonghashtagmorethan20characters`
  - Результат: ошибка "Неправильный хэштег"

7. ✅ **Длинный комментарий**
  - Входные данные: 150 символов
  - Результат: ошибка "Длина комментария больше 140 символов"

8. ✅ **Пустые поля**
  - Входные данные: пустые хэштеги и комментарий
  - Результат: валидация пройдена (поля опциональны)

#### Ручное тестирование

1. ✅ **Открытие формы**
  - Нажатие "Загрузить" → выбор файла → форма открылась

2. ✅ **Закрытие по кнопке**
  - Нажатие кнопки закрытия (×) → форма закрылась

3. ✅ **Закрытие по Esc**
  - Нажатие Esc (фокус вне полей) → форма закрылась

4. ✅ **Esc при фокусе в поле хэштегов**
  - Фокус в поле хэштегов → Esc → форма НЕ закрылась

5. ✅ **Esc при фокусе в поле комментария**
  - Фокус в поле комментария → Esc → форма НЕ закрылась

6. ✅ **Сброс полей при закрытии**
  - Ввод данных → закрытие → повторное открытие → поля пустые

### Результат

✅ **Задание module9-task1 выполнено полностью**

- Форма имеет корректные атрибуты для отправки на сервер
- Реализовано открытие/закрытие формы с учетом всех сценариев
- Все правила валидации работают корректно
- Форма не отправляется при невалидных данных
- Поля сбрасываются при закрытии
- Код соответствует стандартам ESLint

</details>

---

_Не удаляйте и не изменяйте самовольно файлы и папки:_
_`.editorconfig`, `.eslintrc`, `.gitattributes`, `.gitignore`, `package-lock.json`, `package.json`., `.github`_
