# Личный проект «Кексаграм»

* Автор: [Рамиль Зарипов](https://github.com/zarram89).

---

<details>
<summary><b>Техническое задание</b></summary>

## О проекте
Кекстаграм — сервис просмотра изображений. Пользователям предоставлена возможность загружать свои фотографии или просматривать фотографии, загруженные ранее другими пользователями.

## Описание функциональности

### 1. Загрузка нового изображения на сайт и заполнение информации о нём

**1.1. Загрузка нового изображения:**
- выбор файла с изображением для загрузки;
- изменение масштаба изображения;
- применение одного из заранее заготовленных эффектов;
- выбор глубины эффекта с помощью ползунка;
- добавление текстового комментария;
- добавление хэштегов.

**1.2.** Выбор изображения для загрузки осуществляется с помощью стандартного контрола загрузки файла `.img-upload__input`, который стилизован под букву «О» в логотипе. После выбора изображения (изменения значения поля `.img-upload__input`), показывается форма редактирования изображения. У элемента `.img-upload__overlay` удаляется класс `hidden`, а `body` задаётся класс `modal-open`.

После выбора изображения пользователем с помощью стандартного контрола загрузки файла `.img-upload__input`, нужно подставить его в форму редактирования вместо тестового изображения в блок предварительного просмотра и в превью эффектов.

**1.3.** Закрытие формы редактирования изображения производится либо нажатием на кнопку `.img-upload__cancel`, либо нажатием клавиши `Esc`. Элементу `.img-upload__overlay` возвращается класс `hidden`. У элемента `body` удаляется класс `modal-open`.

### 2. Редактирование изображения и ограничения, накладываемые на поля

**2.1. Масштаб:**
- При нажатии на кнопки `.scale__control--smaller` и `.scale__control--bigger` должно изменяться значение поля `.scale__control--value`;
- Значение должно изменяться с шагом в 25. Например, если значение поля установлено в 50%, после нажатия на «+», значение должно стать равным 75%. Максимальное значение — 100%, минимальное — 25%. Значение по умолчанию — 100%;
- При изменении значения поля `.scale__control--value` изображению внутри `.img-upload__preview` должен добавляться соответствующий стиль CSS, который с помощью трансформации `scale` задаёт масштаб. Например, если в поле стоит значение 75%, то в стиле изображения должно быть написано `transform: scale(0.75)`.

**2.2. Наложение эффекта на изображение:**
- По умолчанию должен быть выбран эффект «Оригинал».
- На изображение может накладываться только один эффект.
- Интенсивность эффекта регулируется перемещением ползунка в слайдере. Слайдер реализуется сторонней библиотекой для реализации слайдеров **noUiSlider**. Уровень эффекта записывается в поле `.effect-level__value` в виде числа. При изменении уровня интенсивности эффекта (предоставляется API слайдера), CSS-стили картинки внутри `.img-upload__preview` обновляются следующим образом:
  - Для эффекта «Хром» — `filter: grayscale(0..1)` с шагом 0.1;
  - Для эффекта «Сепия» — `filter: sepia(0..1)` с шагом 0.1;
  - Для эффекта «Марвин» — `filter: invert(0..100%)` с шагом 1%;
  - Для эффекта «Фобос» — `filter: blur(0..3px)` с шагом 0.1px;
  - Для эффекта «Зной» — `filter: brightness(1..3)` с шагом 0.1;
  - Для эффекта «Оригинал» CSS-стили `filter` удаляются.
- При выборе эффекта «Оригинал» слайдер и его контейнер (элемент `.img-upload__effect-level`) скрываются.
- При переключении эффектов, уровень насыщенности сбрасывается до начального значения (100%): слайдер, CSS-стиль изображения и значение поля должны обновляться.

**2.3. Хэштеги:**
- хэштег начинается с символа `#` (решётка);
- строка после решётки должна состоять из букв и чисел и не может содержать пробелы, спецсимволы (`#`, `@`, `$` и т. п.), символы пунктуации (тире, дефис, запятая и т. п.), эмодзи и т. д.;
- хеш-тег не может состоять только из одной решётки;
- максимальная длина одного хэштега 20 символов, включая решётку;
- хэштеги нечувствительны к регистру: `#ХэшТег` и `#хэштег` считаются одним и тем же тегом;
- хэштеги разделяются пробелами;
- один и тот же хэштег не может быть использован дважды;
- нельзя указать больше пяти хэштегов;
- хэштеги необязательны;
- если фокус находится в поле ввода хэштега, нажатие на `Esc` не должно приводить к закрытию формы редактирования изображения.

**2.4. Комментарий:**
- комментарий не обязателен;
- длина комментария не может составлять больше 140 символов;
- если фокус находится в поле ввода комментария, нажатие на `Esc` не должно приводить к закрытию формы редактирования изображения.

### 3. Отправка данных на сервер

**3.1.** После заполнения всех данных, при нажатии на кнопку «Отправить», все данные из формы, включая изображения, с помощью AJAX-запроса отправляются на сервер `https://32.javascript.htmlacademy.pro/kekstagram` методом `POST` с типом `multipart/form-data`. На время выполнения запроса к серверу кнопка «Отправить» блокируется.

**3.2.** Страница реагирует на неправильно введённые значения в форму. Если данные, введённые в форму, не соответствуют ограничениям, указанным в пунктах 2.3 и 2.4, форму невозможно отправить на сервер.

При попытке отправить форму с неправильными данными отправки не происходит, а пользователю показываются ошибки для неверно заполненных полей (для проверки данных используется сторонняя библиотека **Pristine**).

Ошибки выводятся внутри блока `.img-upload__field-wrapper` соответствующего поля. Также, если поле заполнено неверно, блоку, в котором выводится текст ошибки, добавляется класс `.img-upload__field-wrapper--error`.

Пример:
```html
<div class="pristine-error img-upload__field-wrapper--error" style="">Неправильный хэштег</div>
```

Для разных ошибок показываются разные сообщения. Следует разделять случаи, когда:
- введён невалидный хэштег;
- превышено количество хэштегов;
- хэштеги повторяются;
- длина комментария больше 140 символов.

Количество одновременно показываемых сообщений для одного поля разработчик определяет самостоятельно.

**3.3.** При успешной отправке формы форма редактирования изображения закрывается, все данные, введённые в форму, и контрол фильтра приходят в исходное состояние:
- масштаб возвращается к 100%;
- эффект сбрасывается на «Оригинал»;
- поля для ввода хэштегов и комментария очищаются;
- поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

**3.4.** Если отправка данных прошла успешно, показывается соответствующее сообщение. Разметку сообщения, которая находится в блоке `#success` внутри шаблона `template`, нужно разместить перед закрывающим тегом `</body>`. Сообщение должно удаляться со страницы после нажатия на кнопку `.success__button`, по нажатию на клавишу `Esc` и по клику на произвольную область экрана за пределами блока с сообщением.

**3.5.** Если при отправке данных произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке `#error` внутри шаблона `template`, нужно разместить перед закрывающим тегом `</body>`. Сообщение должно удаляться со страницы после нажатия на кнопку `.error__button`, по нажатию на клавишу `Esc` и по клику на произвольную область экрана за пределами блока с сообщением. В таком случае вся введённая пользователем информация сохраняется, чтобы у него была возможность отправить форму повторно.

**3.6.** Нажатие на кнопку `.img-upload__cancel` приводит к закрытию формы и возвращению всех данных и контрола фильтра к исходному состоянию (описано в пункте 3.3). Поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

### 4. Просмотр загруженных изображений

**4.1.** Загрузка изображений от других пользователей производится сразу после открытия страницы с удалённого сервера: `https://32.javascript.htmlacademy.pro/kekstagram/data`.

**4.2.** Если при загрузке данных с сервера произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке `#data-error` внутри шаблона `template`, нужно разместить перед закрывающим тегом `</body>`. Сообщение удаляется со страницы через 5 секунд.

**4.3.** Все загруженные изображения показаны на главной странице в виде миниатюр. DOM-элемент миниатюры генерируется на основе шаблонного элемента `picture`, расположенного в элементе `template` на странице.

**4.4.** При нажатии на любую из миниатюр, показывается блок `.big-picture`, содержащий полноэкранное изображение с количеством лайков и комментариев. Элементу `body` задаётся класс `modal-open`. Данные, описывающие изображение, должны подставляться в соответствующие элементы в разметке.

**4.5.** Выход из полноэкранного режима просмотра фотографии осуществляется либо нажатием на иконку крестика `.big-picture__cancel` в правом верхнем углу блока `.big-picture`, либо нажатием на клавишу `Esc`. У элемента `body` удаляется класс `modal-open`.

**4.6.** Все комментарии к изображению выводятся в блок `.social__comments`. Сразу после открытия изображения в полноэкранном режиме отображается не более 5 комментариев. Количество показанных комментариев и общее число комментариев отображается в блоке `.social__comment-count`. Пример разметки списка комментариев приведён в блоке `.social__comments`. Комментарий оформляется отдельным элементом списка `li` с классом `social__comment`. Аватарка автора комментария отображается в блоке `.social__picture`. Имя автора комментария отображается в атрибуте `alt` его аватарки. Текст комментария выводится в блоке `.social__text`.

**4.7.** Отображение дополнительных комментариев происходит при нажатии на кнопку `.comments-loader`. При нажатии на кнопку отображается не более 5 новых комментариев. При изменении количества показанных комментариев число показанных комментариев в блоке `.social__comment-count` также изменяется.

**4.8.** Если все комментарии показаны, кнопку `.comments-loader` следует скрыть, добавив класс `hidden`.

### 5. Фильтрация изображений от других пользователей

**5.1. Доступные фильтры:**
- «По умолчанию» — фотографии в изначальном порядке с сервера;
- «Случайные» — 10 случайных, не повторяющихся фотографий;
- «Обсуждаемые» — фотографии, отсортированные в порядке убывания количества комментариев.

**5.2.** Блок, с помощью которого производится фильтрация фотографий, скрыт изначально и показывается только после получения от сервера данных об изображениях других пользователей.

**5.3.** При переключении фильтров, отрисовка изображений, подходящих под новый фильтр, должна производиться не чаще, чем один раз 500 мс (устранение дребезга).

</details>

---


<details>
<summary><b>Задание module4-task1: Генерация временных данных</b></summary>

### Описание
В этом задании наша цель научиться генерировать временные данные для дальнейшей разработки интерфейса. Данные хоть временные и ненастоящие, но должны быть идентичны по своей структуре оригинальным.

### Подготовка
В директории `/js` вашего проекта расположен пустой файл `main.js`. Подключите его в файле `index.html` и выполняйте задание в нём.

### Генерация данных

#### Структура объекта фотографии

Нужно создать массив из **25 сгенерированных объектов**. Каждый объект массива — описание фотографии, опубликованной пользователем.

Структура каждого объекта должна быть следующей:

- **id** (число) — идентификатор опубликованной фотографии. Это число от 1 до 25. Идентификаторы не должны повторяться.
- **url** (строка) — адрес картинки вида `photos/{{i}}.jpg`, где `{{i}}` — это число от 1 до 25. Адреса картинок не должны повторяться.
- **description** (строка) — описание фотографии. Описание придумайте самостоятельно.
- **likes** (число) — количество лайков, поставленных фотографии. Случайное число от 15 до 200.
- **comments** (массив объектов) — список комментариев, оставленных другими пользователями к этой фотографии. Количество комментариев к каждой фотографии — случайное число от 0 до 30.

#### Структура объекта комментария

```javascript
{
  id: 135,
    avatar: 'img/avatar-6.svg',
    message: 'В целом всё неплохо. Но не всё.',
    name: 'Артём',
}
```

- **id** (число) — идентификатор комментария. Любое число. Идентификаторы не должны повторяться.
- **avatar** (строка) — строка, значение которой формируется по правилу `img/avatar-{{случайное число от 1 до 6}}.svg`. Аватарки подготовлены в директории `img`.
- **message** (строка) — текст комментария. Одно или два случайных предложения из представленных ниже:
  - Всё отлично!
  - В целом всё неплохо. Но не всё.
  - Когда вы делаете фотографию, хорошо бы убирать палец из кадра. В конце концов это просто непрофессионально.
  - Моя бабушка случайно чихнула с фотоаппаратом в руках и у неё получилась фотография лучше.
  - Я поскользнулся на банановой кожуре и уронил фотоаппарат на кота и у меня получилась фотография лучше.
  - Лица у людей на фотке перекошены, как будто их избивают. Как можно было поймать такой неудачный момент?!
- **name** (строка) — имя автора комментария. Случайное имя из набора, который вы составите сами.

### План выполнения

- [x] Обновить `Readme.md` с полным техническим заданием
- [ ] Подключить `main.js` к `index.html`
- [ ] Реализовать вспомогательные функции для генерации случайных значений
- [ ] Реализовать функции для создания комментариев
- [ ] Реализовать функции для создания фотографий
- [ ] Вывести сгенерированные данные в консоль для проверки

### Ход выполнения

#### 1. Обновление Readme.md ✅
Добавлено техническое задание проекта в свернутом виде (тег `<details>`) и описание текущей задачи module4-task1 с требованиями к структуре данных.

#### 2. Подключение main.js ✅
В файле `index.html` перед закрывающим тегом `</body>` добавлена строка:
```html
<script src="js/main.js"></script>
```

#### 3. Реализация функций генерации данных ✅
В файле `js/main.js` реализованы следующие функции:

**Вспомогательные функции:**
- `getRandomInteger(min, max)` — генерация случайного целого числа в заданном диапазоне
- `getRandomArrayElement(elements)` — получение случайного элемента из массива
- `createIdGenerator()` — фабрика для создания генераторов уникальных ID

**Константы:**
- `MESSAGES` — массив из 6 сообщений для комментариев
- `NAMES` — массив из 12 имен комментаторов
- `DESCRIPTIONS` — массив из 25 описаний фотографий

**Функции генерации:**
- `createComment()` — создание объекта комментария с полями: id, avatar, message, name
- `createComments()` — создание массива случайного количества комментариев (0-30)
- `createPhoto(index)` — создание объекта фотографии с полями: id, url, description, likes, comments
- `createPhotos()` — создание массива из 25 фотографий

**Генерация и вывод:**
```javascript
const photos = createPhotos();
console.log(photos);
```

### Проверка результата

#### Автоматическая проверка ✅
1. Открыт файл `index.html` в браузере
2. Открыта консоль разработчика (F12)
3. В консоли выведен массив из 25 объектов

#### Ручная проверка ✅
Проверена структура данных:
- ✅ Массив содержит ровно 25 элементов
- ✅ Каждая фотография имеет уникальный `id` от 1 до 25
- ✅ URL фотографий имеют формат `photos/1.jpg` ... `photos/25.jpg` (уникальны)
- ✅ Описания фотографий выбираются случайно из предложенного набора
- ✅ Количество лайков находится в диапазоне 15-200
- ✅ Количество комментариев находится в диапазоне 0-30
- ✅ У каждого комментария уникальный ID
- ✅ Аватары комментариев имеют формат `img/avatar-X.svg`, где X от 1 до 6
- ✅ Сообщения комментариев состоят из одного или двух предложений из предложенного набора
- ✅ Имена авторов комментариев выбираются случайно из подготовленного списка

### Результат
✅ Задание module4-task1 выполнено полностью. Созданы все необходимые функции для генерации тестовых данных, соответствующих техническому заданию.

</details>


<details>
<summary><b>Задание module5-task1: Разделение кода на модули</b></summary>

### Описание
Разделите код, уже написанный в `main.js`, на отдельные ES2015-модули. `main.js` станет главным модулем, точкой входа. В этом файле должны остаться только импорты других модулей, а также код, который необходим для их работы.

### Пример разбиения на модули
- **main.js** — точка входа. Модуль, который связывает другие модули
- **util.js** — модуль с вспомогательными функциями
- **data.js** — модуль, который создаёт данные

Указанное выше разделение на модули — это только пример. Вы можете разделить код на модули так, как считаете нужным.

### Задачи
Импортируйте нужные модули в точку входа, а точку входа подключите в `index.html` как скрипт-модуль.

По желанию, вы можете перечитать техническое задание и подумать, какие ещё модули потребуются в приложении, а после завести под них пустые файлы, чтобы сразу обозначить файловую структуру проекта.

### Реализованная структура модулей

#### 1. Основные модули

**util.js** — Вспомогательные функции:
- `getRandomInteger(min, max)` — генерация случайного целого числа
- `getRandomArrayElement(elements)` — выбор случайного элемента из массива
- `createIdGenerator()` — фабрика для создания генераторов уникальных ID

**data.js** — Генерация данных:
- Импортирует функции из `util.js`
- Содержит константы (`MESSAGES`, `NAMES`, `DESCRIPTIONS`)
- Содержит функции создания комментариев и фотографий
- Экспортирует `createPhotos()` для создания массива из 25 фотографий

**main.js** — Точка входа:
- Импортирует `createPhotos` из `data.js`
- Генерирует данные
- Выводит результат в консоль

#### 2. Заготовки модулей для будущей разработки

На основе технического задания созданы заготовки для следующих модулей:
- **form.js** — работа с формой загрузки изображения
- **scale.js** — изменение масштаба изображения
- **effect.js** — применение эффектов к изображению
- **validation.js** — валидация хэштегов и комментариев
- **api.js** — работа с сервером
- **gallery.js** — отображение миниатюр фотографий
- **preview.js** — полноэкранный просмотр фотографии
- **filter.js** — фильтрация изображений
- **upload.js** — загрузка данных на сервер

### Изменения в проекте

#### index.html
Изменено подключение скрипта:
```html
<script src="js/main.js" type="module"></script>
```

### Проверка результата

1. Открыт `index.html` в браузере
2. Открыта консоль разработчика (F12)
3. ✅ В консоли выводится массив из 25 фотографий
4. ✅ Отсутствуют ошибки в консоли
5. ✅ Модули корректно импортируют друг друга

### Возможные проблемы и решения

**Проблема:** CORS-ошибка при локальном открытии файла
**Решение:** Использовать локальный веб-сервер (например, Live Server в VS Code или `python -m http.server`)

**Проблема:** Браузер не поддерживает ES6-модули
**Решение:** Использовать современный браузер (Chrome, Firefox, Edge последних версий)

### Преимущества модульного подхода

1. **Разделение ответственности**: каждый модуль выполняет свою задачу
2. **Переиспользование**: модули можно импортировать в разных частях проекта
3. **Тестируемость**: модули удобно тестировать изолированно
4. **Масштабируемость**: легко добавлять новые модули
5. **Читаемость**: структура кода понятна и логична
6. **Инкапсуляция**: внутренние функции модуля недоступны извне

### Результат
✅ Задание module5-task1 выполнено полностью. Код разделен на логические модули, создана основа для дальнейшей разработки проекта.

</details>


<details>
<summary><b>Задание module7-task1: Отрисовка миниатюр фотографий</b></summary>

### Описание
Отобразить фотографии других пользователей. Завести модуль, который будет отвечать за отрисовку миниатюр.

На основе временных данных для разработки и шаблона `#picture` создать DOM-элементы, соответствующие фотографиям, и заполнить их данными.

### Требования к заполнению

- Адрес изображения `url` подставить как атрибут `src` изображения
- Описание изображения `description` подставить в атрибут `alt` изображения
- Количество лайков `likes` вывести в блок `.picture__likes`
- Количество комментариев `comments.length` вывести в блок `.picture__comments`

Отрисовать сгенерированные DOM-элементы в блок `.pictures`. Для вставки элементов использовать `DocumentFragment`.

### Реализованная структура

#### 1. Модуль gallery.js

**Функции модуля:**

- `createPictureElement(photo)` — создание DOM-элемента миниатюры
  - Клонирует шаблон `#picture`
  - Заполняет данными из объекта photo
  - Возвращает готовый элемент

- `renderPictures(photos)` — отрисовка всех миниатюр
  - Создает `DocumentFragment`
  - Создает элементы для каждой фотографии
  - Вставляет фрагмент в контейнер `.pictures` за одну операцию

**Экспорт:**
```javascript
export { renderPictures };
```

#### 2. Интеграция в main.js

Модуль подключен в проект через импорт:

```javascript
import { createPhotos } from './data.js';
import { renderPictures } from './gallery.js';

const photos = createPhotos();
renderPictures(photos);
```

### Проверка результата

1. Открыт `index.html` в браузере через локальный сервер
2. ✅ На странице отображаются 25 миниатюр фотографий
3. ✅ Каждая миниатюра содержит:
  - Изображение с корректным URL (`photos/1.jpg` ... `photos/25.jpg`)
  - Описание в атрибуте `alt`
  - Количество лайков (15-200)
  - Количество комментариев (0-30)
4. ✅ Использован `DocumentFragment` для оптимизации
5. ✅ Отсутствуют ошибки в консоли

### Особенности реализации

1. **Производительность**: `DocumentFragment` минимизирует количество reflow при вставке 25 элементов
2. **Модульность**: отрисовка полностью отделена от генерации данных
3. **Шаблонизация**: использование `<template>` обеспечивает быстрое клонирование
4. **Переиспользование**: функцию можно вызывать повторно для обновления галереи

### Результат
✅ Задание module7-task1 выполнено полностью. Миниатюры корректно отображаются с данными из временного массива.

</details>


<details>
<summary><b>Задание module8-task1: Полноразмерный просмотр фотографий</b></summary>

### Описание
Реализовать сценарий просмотра фотографий в полноразмерном режиме. При клике на миниатюру открывается модальное окно с большим изображением, комментариями и лайками.

### Требования

При клике на миниатюру должно открываться окно `.big-picture` (удаляется класс `hidden`). Окно заполняется данными:

- **Изображение**: `url` → `.big-picture__img img[src]`
- **Лайки**: `likes` → `.likes-count`
- **Описание**: `description` → `.social__caption`
- **Комментарии**: массив `comments` → `.social__comments`
- **Счетчики**: показано и всего → `.social__comment-shown-count` и `.social__comment-total-count`

Каждый комментарий имеет структуру:
```html
<li class="social__comment">
  <img class="social__picture" src="{{avatar}}" alt="{{name}}" width="35" height="35">
  <p class="social__text">{{message}}</p>
</li>
```

После открытия окна:
- Скрыть блоки `.social__comment-count` и `.comments-loader`
- Добавить класс `modal-open` к `<body>`
- Реализовать закрытие по Esc и клику на `.big-picture__cancel`

### Реализованная структура

#### 1. Модуль preview.js

**Основные функции:**

- `renderComments(comments)` — отрисовка списка комментариев с использованием DocumentFragment
- `fillBigPicture(photo)` — заполнение всех данных окна
- `showBigPicture(photo)` — открытие модального окна
- `closeBigPicture()` — закрытие модального окна
- `onDocumentKeydown(evt)` — обработчик клавиши Esc

**Экспорт:**
```javascript
export { showBigPicture };
```

#### 2. Интеграция в gallery.js

Добавлен импорт и обработчик клика на каждую миниатюру:

```javascript
import { showBigPicture } from './preview.js';

pictureElement.addEventListener('click', (evt) => {
  evt.preventDefault();
  showBigPicture(photo);
});
```

### Проверка результата

1. Открыта страница в браузере
2. ✅ Клик на миниатюру открывает модальное окно
3. ✅ Отображаются корректные данные:
  - Большое изображение
  - Количество лайков
  - Описание фотографии
  - Все комментарии с аватарами
4. ✅ Окно закрывается по клику на кнопку
5. ✅ Окно закрывается по нажатию Esc
6. ✅ Класс `modal-open` добавляется/удаляется корректно
7. ✅ Блоки счетчика и загрузки скрыты

### Особенности реализации

1. **Модульность**: логика просмотра отделена от галереи
2. **UX**: блокировка прокрутки body при открытом окне
3. **Оптимизация**: DocumentFragment для вставки комментариев
4. **Доступность**: закрытие по Esc
5. **Замыкания**: сохранение ссылки на объект photo в обработчике

### Результат
✅ Задание module8-task1 выполнено полностью. Полноразмерный просмотр работает корректно со всеми требованиями.

</details>

---

_Не удаляйте и не изменяйте самовольно файлы и папки:_
_`.editorconfig`, `.eslintrc`, `.gitattributes`, `.gitignore`, `package-lock.json`, `package.json`., `.github`_
